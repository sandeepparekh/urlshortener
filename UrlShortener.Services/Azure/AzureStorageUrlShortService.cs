using Microsoft.Extensions.Logging;
using Microsoft.WindowsAzure.Storage.Table;
using System;
using System.Linq;
using System.Threading.Tasks;
using UrlShortener.Extensions.BaseX;
using UrlShortener.Extensions.Md5;
using UrlShortener.Models.Azure;
using UrlShortener.Models.Common;
using UrlShortener.Repositories;

namespace UrlShortener.Services.Azure
{
    public class AzureStorageUrlShortService : IUrlShortService
    {
        private readonly IAppSettings _settings;
        private readonly char[] _alphabets;
        private readonly IUrlRepository _urlRepository;
        private readonly ICacheService _cacheService;
        private readonly ILogger _logger;
        private readonly int _shortUrlCodeLength;

        public AzureStorageUrlShortService(IAppSettings settings,
            IUrlRepository urlRepository,
            ICacheService cacheService,
            ILogger<AzureStorageUrlShortService> logger)
        {
            _settings = settings;
            _alphabets = _settings.EncodingAlphabet.Select(c => c).ToArray();
            _urlRepository = urlRepository;
            _cacheService = cacheService;
            _logger = logger;
            _shortUrlCodeLength = _settings.ShortUrlCodeLength;
        }

        private async Task<Result<string>> ProcessForDuplicateShortUrlCode(string base62, string shortUrlCode, string longUrl, string userId)
        {
            var bitstaken = _shortUrlCodeLength;
            _logger.LogWarning(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has already been used. Trying another..");
            while (true)
            {
                shortUrlCode = string.Join("", base62.Skip(bitstaken).Take(_settings.ShortUrlCodeLength));
                if (shortUrlCode.Length < _shortUrlCodeLength || shortUrlCode.Contains('='))
                {
                    _logger.LogError(LoggingEvents.CreateShortUrlCode, "All possible option from base62 string for a short url code have been exhausted.");
                    return new Result<string>
                    {
                        Success = false,
                        Error = "Unable to generate a short URL code"
                    };
                }
                var pk = shortUrlCode.Substring(0, 3);
                bitstaken += _shortUrlCodeLength;
                var existingRedirectEntity = await _urlRepository.GetRedirectOptimizedUrl(pk, shortUrlCode);
                if (existingRedirectEntity != null)
                {
                    _logger.LogWarning(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has already been used. Trying another..");
                    continue; // another duplication
                }

                var redirOptimizedEnt = new Url(pk, shortUrlCode, longUrl);
                var readOptimizedEnt = new Url(userId, shortUrlCode, longUrl);

                await _urlRepository.CreateUrl(redirOptimizedEnt, readOptimizedEnt);
                _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has been Generated for {longUrl}");

                return new Result<string>
                {
                    Success = true,
                    Data = shortUrlCode
                };
            }
        }

        public async Task<Result<string>> CreateUrl(string longUrl, string userId = "anon")
        {
            _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"Generating Short Url Code for {longUrl}");
            try
            {
                var urlToHash = longUrl;
                if (!string.Equals(userId, "anon"))
                {
                    _logger.LogDebug(LoggingEvents.CreateShortUrlCode, "Request has been generated by a logged in user");
                    urlToHash += userId;
                }

                var base62 = urlToHash.GetMd5Hash().ToBaseX(_alphabets);
                var shortUrlCode = base62.Substring(0, _shortUrlCodeLength);
                var pk = shortUrlCode.Substring(0, 3);

                var redirOptimizedEnt = new Url(pk, shortUrlCode, longUrl);
                var readOptimizedEnt = new Url(userId, shortUrlCode, longUrl);

                var result = new Result<string>
                {
                    Success = true,
                    Data = shortUrlCode
                };

                var existingRedirectEntity = await _urlRepository.GetRedirectOptimizedUrl(pk, shortUrlCode);
                if (existingRedirectEntity == null)
                {
                    _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has been Generated for {longUrl}");
                    await _urlRepository.CreateUrl(redirOptimizedEnt, readOptimizedEnt);
                    return result;
                }
                if (string.Equals(existingRedirectEntity.LongUrl, longUrl))
                {
                    _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"There is already an entry for {shortUrlCode}-{longUrl}. Returning same Url Short Code.");
                    return result;
                }
                // duplicate short url code
                return await ProcessForDuplicateShortUrlCode(base62, shortUrlCode, longUrl, userId);
            }
            catch (Exception ex)
            {
                _logger.LogError(LoggingEvents.CreateShortUrlCode, ex, ex.Message);
                return new Result<string>
                {
                    Error = ex.Message,
                    Success = false
                };
            }
        }

        public async Task<Result<string>> GetLongUrl(string shortUrlCode)
        {
            try
            {
                var cachedValue = _cacheService.GetCache(shortUrlCode);
                if (!string.IsNullOrEmpty(cachedValue)) return new Result<string>
                {
                    Success = true,
                    Data = cachedValue
                };

                if (shortUrlCode.Length != _shortUrlCodeLength) return null;
                var url = await _urlRepository.GetRedirectOptimizedUrl(shortUrlCode.Substring(0, 3), shortUrlCode);
                _cacheService.SetCache(shortUrlCode, url.LongUrl);
                return new Result<string>
                {
                    Success = true,
                    Data = url.LongUrl
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(LoggingEvents.GetUrl, ex, ex.Message);
                return new Result<string>
                {
                    Success = false,
                    Error = ex.Message
                };
            }
        }

        public async Task<UrlListResult> GetUrls(string userId, TableContinuationToken token = null)
        {
            try
            {
                return await _urlRepository.GetUrls(userId, token);
            }
            catch (Exception ex)
            {
                _logger.LogError(LoggingEvents.GetUrls, ex, ex.Message);
                return new UrlListResult
                {
                    Success = false,
                    Error = ex.Message
                };
            }
        }
    }
}