using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.WindowsAzure.Storage.Table;
using UrlShortener.Extensions.BaseX;
using UrlShortener.Extensions.Md5;
using UrlShortener.Models.Azure;
using UrlShortener.Models.Common;
using UrlShortener.Repositories;

namespace UrlShortener.Services.Azure
{
    public class AzureStorageUrlShortService : IUrlShortService
    {
        private readonly IAppSettings _settings;
        private readonly char[] _alphabets;
        private readonly IUrlRepository _urlRepository;
        private readonly ICacheService _cacheService;

        private readonly ILogger _logger;
        public AzureStorageUrlShortService(IAppSettings settings,
            IUrlRepository urlRepository,
            ICacheService cacheService,
            ILogger<AzureStorageUrlShortService> logger)
        {
            _settings = settings;
            _alphabets = _settings.EncodingAlphabet.Select(c => c).ToArray();
            _urlRepository = urlRepository;
            _cacheService = cacheService;
            _logger = logger;
        }


        public async Task<Result<string>> CreateUrl(string longUrl, string userId = "anon")
        {
            _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"Generating Short Url Code for {longUrl}");
            var bitstaken = _settings.ShortUrlCodeLength;
            try
            {
                var urlToHash = longUrl;
                if (!string.Equals(userId, "anon"))
                {
                    _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"Request has been generated by a logged in user");
                    urlToHash += userId;
                }

                var base62 = urlToHash.GetMd5Hash().ToBaseX(_alphabets);
                var shortUrlCode = base62.Substring(0, _settings.ShortUrlCodeLength);
                var pk = shortUrlCode.Substring(0, 3);

                var redirOptimizedEnt = new Url(pk, shortUrlCode, longUrl);
                var readOptimizedEnt = new Url(userId, shortUrlCode, longUrl);

                var result = new Result<string>
                {
                    Success = true,
                    Data = shortUrlCode
                };

                var existingRedirectEntity = await _urlRepository.GetRedirectOptimizedUrl(pk, shortUrlCode);
                if (existingRedirectEntity == null)
                {
                    _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has been Generated for {longUrl}");
                    await _urlRepository.CreateUrl(redirOptimizedEnt, readOptimizedEnt);
                    return result;
                }
                if (string.Equals(existingRedirectEntity.LongUrl, longUrl))
                {
                    _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"There is already an entry for {shortUrlCode}-{longUrl}. Returning same Url Short Code.");
                    return result;
                }

                _logger.LogWarning(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has already been used. Trying another..");
                while (true)
                {
                    shortUrlCode = string.Join("", base62.Skip(bitstaken).Take(_settings.ShortUrlCodeLength));
                    if (shortUrlCode.Length < _settings.ShortUrlCodeLength || shortUrlCode.Contains('='))
                    {
                        _logger.LogError(LoggingEvents.CreateShortUrlCode, $"All possible option from base62 string for a short url code have been exhausted.");
                        return new Result<string>
                        {
                            Success = false,
                            Error = "Unable to generate a short URL code"
                        };
                    }
                    pk = shortUrlCode.Substring(0, 3);
                    bitstaken += _settings.ShortUrlCodeLength;
                    existingRedirectEntity = await _urlRepository.GetRedirectOptimizedUrl(pk, shortUrlCode);
                    if (existingRedirectEntity != null)
                    {
                        _logger.LogWarning(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has already been used. Trying another..");
                        continue; // another duplication
                    }

                    redirOptimizedEnt.PartitionKey = pk;
                    redirOptimizedEnt.RowKey = shortUrlCode;
                    readOptimizedEnt.RowKey = shortUrlCode;
                    await _urlRepository.CreateUrl(redirOptimizedEnt, readOptimizedEnt);
                    _logger.LogDebug(LoggingEvents.CreateShortUrlCode, $"{shortUrlCode} has been Generated for {longUrl}");

                    return new Result<string>
                    {
                        Success = true,
                        Data = shortUrlCode
                    };
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(LoggingEvents.CreateShortUrlCode, ex, ex.Message);
                return new Result<string>
                {
                    Error = ex.Message,
                    Success = false
                };
            }
        }

        public async Task<Result<string>> GetLongUrl(string shortUrlCode)
        {
            try
            {
                var cachedValue = _cacheService.GetCache(shortUrlCode);
                if (!string.IsNullOrEmpty(cachedValue)) return new Result<string>
                {
                    Success = true,
                    Data = cachedValue
                };

                if (shortUrlCode.Length != _settings.ShortUrlCodeLength) return null;
                var url = await _urlRepository.GetRedirectOptimizedUrl(shortUrlCode.Substring(0, 3), shortUrlCode);
                _cacheService.SetCache(shortUrlCode, url.LongUrl);
                return new Result<string>
                {
                    Success = true,
                    Data = url.LongUrl
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(LoggingEvents.GetUrl, ex, ex.Message);
                return new Result<string>
                {
                    Success = false,
                    Error = ex.Message
                };
            }

        }

        public async Task<UrlListResult> GetUrls(string userId, TableContinuationToken token = null)
        {
            try
            {
                return await _urlRepository.GetUrls(userId, token);
            }
            catch (Exception ex)
            {
                _logger.LogError(LoggingEvents.GetUrls, ex, ex.Message);
                return new UrlListResult
                {
                    Success = false,
                    Error = ex.Message
                };
            }
        }

        public async Task<Result<bool>> DeleteUrl(string shortUrlCode, string userId)
        {
            try
            {
                var result = await _urlRepository.DeleteUrl(shortUrlCode, userId);
                return new Result<bool>
                {
                    Success = true,
                    Data = result
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(LoggingEvents.DeleteUrl, ex, ex.Message);
                return new Result<bool>
                {
                    Success = false,
                    Error = ex.Message
                };
            }
        }
    }
}
